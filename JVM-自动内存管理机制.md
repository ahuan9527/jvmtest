# JVM学习之自动内存管理机制 #
## 1. 运行时数据区域 ##
![](https://i.imgur.com/Ch5t80H.png)
### 1.1 程序计数器 ###
   
- 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器
- 每一个线程都有一个独立的程序计数器，且互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
### 1.2 JAVA虚拟机栈 ###
- 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。
- JAVA方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
- 每一个方法从调用到完成，对应着一个栈帧在虚拟机栈中的入栈出栈
- 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
### 1.3 本地方法栈 ###
- 虚拟机栈为JAVA(字节码)方法服务，本地方法栈为Native方法服务
### 1.4 Java堆 ###
- JAVA堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建，唯一目的就是存放对象实例，不过随着JIT的发展与逃逸技术，栈上分配，标量替换优化技术将导致一些微妙的变化，只在堆上存放对象实例也不是那儿么‘绝对’
- JAVA堆可以细分为Eden空间、From Survivor 空间、To Survivor空间等，划分的目的就是为更好的进行回收何分配
### 1.5 方法区 ###
- 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。
### 1.6 运行时常量池 ###
- 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
### 1.7 直接内存 ###
- 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，堆外内存。

----------

## 2.HotSpot虚拟机 ##
### 2.1对象的创建 ###
- 创建对象时，虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，检查通过，Java堆进行内存分配，根据采用的是什么垃圾回收决定堆是否规整，是采用'指针碰撞'，否则采用空闲列表
- <font size="4">解决并发创建对象问题</font>，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲
### 2.2 对象的内存布局 ###
- 对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）
   - 对象头（Header）：两部分，一部分为哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称为：Mark Word
   ![](https://i.imgur.com/EzL7Bmx.png)	
   - 对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
   - 第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。
### 2.3 对象的访问定位 ###
- 建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。
- 使用句柄访问对象
	- 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改 
 ![](https://i.imgur.com/DmVR9Pi.png)
- 使用直接指针访问对象
	- 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见
 ![](https://i.imgur.com/7Sxf3RY.png)
### 2.4 实战：OutOfMemoryError异常 ###
#### 2.4.1 Java堆溢出 ####
- Args:-Xms20m-Xmx20m-XX:+HeapDumpOnOutOfMemoryError
   - -xms xmx 设置Java堆的大小  
   - MaxPermSize（最大方法区容量）
   - +HeapDumpOnOutOfMemoryError 生成dump文件
   - -Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定
#### 2.4.2 虚拟机栈和本地方法栈溢出 ####
   - 在Java虚拟机规范中描述了两种异常：
      - 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。	
      - 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。
    - 如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的处理经验，这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到。 
#### 2.4.3 方法区和运行时常量池溢出 ####	
   - string.intern() string.intern()是一个native方法，它的作用是：如果字符串常量池中已经包含一个等于此string对象的字符串，则返回代表池中这个字符串的string对象；否则，将此string对象包含的字符串添加到常量池中，并且返回此string对象的引用。
   - -xx:permsize和-xx:maxpermsize限制方法区大小
```Exception in thread"main"java.lang.OutOfMemoryError:PermGen space
at java.lang.String.intern（Native Method）```
#### 2.4.4本机直接内存溢出 ####
- DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样

## 第3章　垃圾收集器与内存分配策略 ##
### 3.1 概述 ###
- 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。
- 程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，
JAVA堆和方法区不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样。
### 3.2 对象已死 ###
- 堆里存放的几乎所有的对象，如何判断对象是否还存活
#### 3.2.1 引用计数算法 ####
- 实现简单，判定效率高，大部分情况下是一个不错的算法，微软公司的COM技术，使用ActionScript3的FlashPlayer，Python语言等
- 缺点很难解决对象之间相互循环引用的问题
#### 3.2.2 可达性分析 ####
- 在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中，都是称通过可达性分析（Reachability Analysis）来判定对象是否存活的。
- 个算法的基本思路就是通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的
- 可作为GC ROOTS 的对象包含下面
   - 虚拟机栈（栈帧中的本地变量表）中引用的对象。
   - 方法区中类静态属性引用的对象。
   - 方法区中常量引用的对象。
   - 本地方法栈中JNI（即一般说的Native方法）引用的对象。
![](https://i.imgur.com/h456laQ.png)
#### 3.2.3 引用 ####
- Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。
- 强引用：就是指在程序代码之中普遍存在的，类似"Object obj=new Object()"这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
- 软引用：是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。
- 弱引用：也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。
- 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。
#### 3.2.5　回收方法区 ####
- Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。
- 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类
   - 回收废弃常量：与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串"abc"已经进入了常量池中，但是当前系统没有任何一个String对象是叫做"abc"的，换句话说，就是没有任何String对象引用常量池中的"abc"常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个"abc"常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。
   - 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：
      - 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
      -  加载该类的ClassLoader已经被回收。
      -  该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
   -  是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。
### 3.3　垃圾收集算法 ###
- 各个平台的虚拟机操作内存的方法又各不相同
#### 3.3.1　标记-清除算法 ####
- 算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了
- 一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记—清除算法的执行过
![](https://i.imgur.com/jytEFjE.png)
#### 3.3.2　复制算法 ####
- 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块使用完了，将活着的对象复制到另外一块，清理掉使用过的内存空间，这样使得每次回收都是整个内存半区回收，缺点：将内存缩小为原来的一半!
![](https://i.imgur.com/k9cawu8.png)
![](https://i.imgur.com/2fas9Wj.png)
#### 3.3.3　标记-整理算法 ####
- 标记方法同"标记-清除算法"一致，但是再垃圾回收时，并不直接回收，而是将存活的对象移动到一块，然后在统一清除、
![](https://i.imgur.com/M05kFOA.png)
#### 3.3.4　分代收集算法 ####
- 根据对象的存活周期将内存划分几块区域，一般JAVA 堆分为新生代和老年代 ，新生代中每次收集大批对象死亡，所以采用复制算法。老年代中对象存活比较长，所以采用标记算法